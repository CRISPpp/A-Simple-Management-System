大一和同学一起做的大作业我负责的部分，比较简陋的管理系统，有一些奇奇怪怪的功能，可视化主要基于easyx，过程中用了一系列入门的算法，比如Dijkstra、RMQ之类的，因为当时比较无聊还写了个可有可无的数独小游戏


下列是一些主要功能
virtual void get_information() = 0;		//添加信息
virtual void print_information() = 0;	//打印所有信息
virtual void seek_information() = 0;	//寻找目标信息
virtual void clear_information() = 0;	//清空信息
市场运营部的主体部分是Marketing Department，主要定义了抽象基类的五个虚函数，即添加信息、打印所有信息、寻找目标信息、清空信息以及修改密码的功能，市场运营部主要是储存同时增加了另外八个函数来实现市场部门运营的功能：
void max_profit();			  //计算最大的利益
void enquary_max_min_profit();//查询指定编号区间订单的最值状态 
void shortest_path();	 	  //根据路线选择最有利于公司的方案  
void addprofit();				  //增加区间订单的价值
void book_room();				  //预定会议室
void sort_information();		  //按编号大小或者价值大小对订单排序
void meanue();				  //显示菜单，提供用户选择和退出接口
void shudu_game();			  //为了防止管理人员无聊的数独小游戏

get_information主要用于追加新的订单，记录订单的编号，以及该订单的价值，并将结果保存到文件中。
print_information将以保存的订单信息输出，通过设计好的界面显示。
seek_information提供一个接口，让用户输入查询的编号，并在记录的信息中找到该编号，如果找不到就报错，否则，输出订单的编号和价值，方便管理者进行查找。
clear_information是将记录好的所有信息全部清空，初始化订单文件。
max_profit是结合公司资源有限的现状，由于资源有限，市场部门完成一批订单后不能立即就开始新的一批订单，即要休息一段时间，此时只能跳到下一次相邻的订 单，依据记录的销售状况，获取最大获利的利益。计算后将最大利益输出并记录到文件中。           
enquary_max_min_profit即查询某个区间内订单的最大值和最小值，可进行多次查询，让管理者能快速检查最近的销售状况。
shortest_path 是公司需要对商品进行配送，输入城市和路线，计算最小消耗路径，需要先存入地区的信息，然后根据这些信息以及路线消耗的资源进行整合计算，输出图的邻接矩阵，然后输出公司所在地，即出发点到其余各点的最小消耗路径。
addprofit 提供一个改变区间订单值的接口，可输入具体的区间编号和具体增加或减少的值，对应的内容会改变。
book_room 是预定会议室的接口，可对会议室进行初始化，输入会议室的编号，查询该会议室是否能预定，如果能则可预定。
sort_information，提供排序信息的接口，用户可选择按编号大小或者按订单价值大小对订单信息进行排序。
meanue 用于显示菜单，提供用户选择的接口以及退出的接口。
shudu_game 是提供一个数独的题目，需要玩家自行分析出结果，然后输入



设计部分
主界面的设计我用了easyx进行设计，设计了bgm还有背景图，划分了十二个矩阵方便操作者接入各个函数。
Seek_information,get_information和print_information以及clear_information主要通过对文件的输出和输入实现，即ifstream和ofstream。并将文件都保存到“test_market”的文件中。
max_profit读取“test_market”的数据，并通过dp计算出各个时间对应利益的最大值，循环过程主要选取日期前一天之前出现的最大的价值，更新每个日期对应的价值，保存起来。
enquary_max_min_profit用了ST表RMQ的算法，maxn[i][j]表示第i个编号到2^j最大的订单价值，同理minn[i][j]表示第i个编号到2^j最小的订单价值，先列后行的初始化方式来储存数据。查询时先算出区间可容纳的最大的2的几次方，即z，通过交集来求出各个值。
shortest_path主要运用迪杰斯特拉即Dijkstra算法，先建立邻接矩阵，然后先将起点到各个点距离设置为无穷，根据邻接矩阵更新点到其他最短的距离，更新完后将该点加入答案队列，然后选权值最小的点进行更新，重复以上过程直至所有点入队。计算过程中不断更新结果。
Addprofit主要利用差分的算法，将原数值作为差分数组的前缀和，然后加入值时只需修改差分数组的左区间和右区间，最后把所有的值加起来，数组就是最终的结果。
book_room主要是运用文件操作，将数据储存到“room_message”中。
sort_information主要通过快排和归并排序对编号或价值大小进行升序排序，当数据大小大于1e8时用归并排序会更快，小于时选择快排。快排主要采用分治的思想和双指针双法，每次选区间中点为标准，小于的排左边，大于排右边。归并也通过递归分治进行实现。
shudu_game只提供给用户一个题目，程序先通过递归回溯的算法得出答案，然后将操作者输入的数据进行比对。

